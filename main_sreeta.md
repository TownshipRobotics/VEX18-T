#pragma config(Sensor, in1,             pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,           carrierBtn,     sensorTouch)
#pragma config(Sensor, dgtl2,           rightUltSensor, sensorSONAR_mm)
#pragma config(Sensor, dgtl4,           leftUltSensor,  sensorSONAR_mm)
#pragma config(Motor,  port2,           leftWheel,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightWheel,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           flipperRight,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           flipperLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armLeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armRight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,           tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//************************
//         CONFIG
//************************
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"


//************************
//       VARIABLES
//************************
bool up = true;   // Whether the carrier is up or not
//float timeForward = 0;	// how much time it took to reach mobile goal and remove if you do not use timer

//*************************
//         METHODS
//*************************

/***** MOVEMENT *****/

/* Move the robot forward/backward
		wheelPower: [-127, 127] how fast the robot goes
				(+) => forwards
				(-) => backwards      */
void moveWheels(int wheelPower) {
	motor[leftWheel] = -wheelPower;
	motor[rightWheel] = wheelPower-1; //dont change! made so robot does not curve
}

/* Stops all wheel movement */
void stopWheels() {
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

/* Turns 180 counterclockwise */
void turnLeft() {
	motor[leftWheel] = -60;
	motor[rightWheel] = -60;
	sleep(2750);
	stopWheels();
}

/* Turns 180 clockwise */
void turnRight() {
	motor[leftWheel] = 60;
	motor[rightWheel] = 60;
	sleep(2750);
	stopWheels();
}


//***** FLIPPER *****
void flipCap(){
  	motor[fliiperLeft] = -60;//turns the cap over... hopefully
	motor[flipperRight] = -60;
	sleep(2750);
	stopWheels();
}
   

//***** AUTONOMOUS *****


//parking bonus
void auto(){
	//flip cap
	flipCap();
	moveWheels(40);
	sleep(100);
	stopWheels();
}


//***** DRIVING *****
/* Controls:
		Left joystick  => Left wheels
		Right joystick => Right wheels
		5U ........... => Raise arm
		5D ........... => Lower arm
		6U ........... => Open claw
		6D ........... => Close claw
		8R ........... => Lower carrier
		8D ........... => Raise carrier
*/

/* Curves the input to give a smoother driving experience
https://www.desmos.com/calculator/xv2hbpabjm        */
int modify(int input) {
	return (input+(pow(input,5)/8192-pow(input,3))/8192)/3;
}

//it needed to be faster so i made a slight alteration
//https://www.desmos.com/calculator/xv2hbpabjm
int modify2(int input) {
	return (input+(pow(input,5)/8192-pow(input,3))/8192)/2;
}

/* Update wheel powers based on controller */
void updateWheels() {
	motor[leftWheel] = -modify2(vexRT[Ch3]);
	motor[rightWheel] = modify2(vexRT[Ch2]);
}

/* Update claw power based on controller */
void updateFlipper() {
	if(vexRT[Btn6U] == 1) // If upper Z button down
		motor[claw] = 60;
	else if(vexRT[Btn6D] == 1) // If lower Z button down
		motor[claw] = -60;
	else
		motor[claw] = 0;
}



/* Updates carrier powers based on controller */
void updateMobileGoal() {
	// If carrier is currently up and lower button pressed
	if(up && vexRT[Btn8R] == 1) {
		lowerCarrier();
		up = false;
	// If carrier is currently down and raise button pressed
	} else if(!up && vexRT[Btn8D] == 1) {
		raiseCarrier();
		up = true;
	}
}


//*************************
//          TASKS
//*************************

void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {
	auto();
}

task usercontrol() {
	while (true) {
		updateWheels();
		updateFlipper();
		updateMobileGoal();
	}
}
